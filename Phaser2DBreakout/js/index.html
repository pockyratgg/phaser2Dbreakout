<!doctype html>
<html lang="en-US">
    <head>
        <meta charset="utf-8"/>
        <title> Gamedev Phaser - Workshop - lesson 01: Initialize the framework</title>
        <style>
            * {
                padding: 0;
                margin: 0;
            }
        </style>
        <!--if having trouble, make sure this path is correct. adding another / before js showed the black canvas-->
        <script src="/js/phaser.min.js"></script>
    </head>
    <body>
        <script>
            //canvas element is automatically generated by framework. we are initializing it here
            //the parameters are width, height, rendering method. there are three options, auto, canvas, and webgl.
            //the id of the canvas is here as well. we are using null because we want Phaser to create its own
            const game = new Phaser.Game(480, 320, Phaser.CANVAS, null, {
                preload, //takes care of preloading assets
                create, //executes once everything is loaded and ready
                update, //exectued every frame
            });

            //initializing a variable for the ball here. tutorial is using global variables only for now.
            let ball;
            let paddle;

            //initializing brick variables
            let bricks;
            let newBrick;
            let brickInfo;

            //setting variables for the score
            let scoreText;
            let score = 0;

            //setting variables for lives
            let lives = 3;
            let livesText;
            let lifeLostText;

            //adding in variables for a start button
            let playing = false;
            let startButton;

            function preload() {
                //special scale object used in Phaser that scales based on different screen sizes. current settings center the canvas on the screen regardless of size
                game.scale.scaleMode = Phaser.ScaleManager.SHOW_ALL;
                game.scale.pageAlignHorizontally = true;
                game.scale.pageAlignVertically = true;

                //adds in a custom color canvas background which is black
                game.state.backgroundColor = "#eee";

                //initializing ball sprite
                game.load.image("ball", "img/ball.png");

                //initializing the paddle sprite
                game.load.image("paddle", "img/paddle.png");

                //loading in brick image
                game.load.image("brick", "img/brick.png");

                //loading in spritesheet. instead of loading a single image of the ball, we load in the whole spritesheet
                game.load.spritesheet("ball", "img/wobble.png", 20, 20);

                //loading the start button spritesheet. single button frame is 120 pixels wide and 40 pixels high
                game.load.spritesheet("button", "img/button.png", 120, 40);

            } //end of preload
            function create() {
                //using Phaser's built in physics engine, arcade physics. other choices include P2 and ninja physics and box2D
                game.physics.startSystem(Phaser.Physics.ARCADE);

                //creating the ball object and rendering it on screen. first two parameters are the x and y coordinates and the third is the name of the asset we decided from earlier
                //ball = game.add.sprite(50, 50, "ball");

                //positioning our ball on screen and then setting the anchor to the middle of the ball sprite
                ball = game.add.sprite(game.world.width * 0.5, game.world.height - 25, "ball");

                //adding ball animation here. paramters include the name we chose for the animation, an array defining the order in which to display the frames during the animation
                //spritesheet has three frames, phaser extracts this and stores references to them in an array, 0, 1, 2. array is saying which frame to show
                //the last parameter is the frame rate. we are running the animation at 24fps, there are 9 frames, the animation will display just under three times per second
                ball.animations.add("wobble", [0, 1, 0, 2, 0, 1, 0, 2, 0], 24);
                ball.anchor.set(0.5);

                //initializing the physics to work with our ball object
                game.physics.enable(ball, Phaser.Physics.ARCADE);

                //setting the world boundary so the ball doesn't go outside of it. doesn't bounce just rolls to a stop
                ball.body.collideWorldBounds = true;

                //making the ball bounce when it collides with the world boundary. increasing the parameter makes it bounce much faster
                ball.body.bounce.set(1);

                //setting velocity on the ball's body. at the moment, gravity and friction are set to 0. second value is changed to negative so the ball starts the game moving upwards instead of downwards
                //ball.body.velocity.set(150, -150);

                //ball.body.gravity.y = -500; setting gravity to a negative value causes it to dip upwards

                //disabling the ball's collision with only the bottom edge of the screen so we can introduce the ability to lose
                game.physics.arcade.checkCollision.down = false;

                //this makes the ball check the world(canvas) and execute the function bound to the onOutofBounds event. when clicking on the alart, the page will be reloaded so the game can be played again
                ball.checkWorldBounds = true;

                //checking to see if  the ball leave the sccreen so lives can be incorporated
                ball.events.onOutOfBounds.add(ballLeaveScreen, this);

                //creating the paddle object and rendering it on screen
                paddle = game.add.sprite(
                    game.world.width * 0.5, //sets the paddle position exactly where we want it. 0.5 is the middle of the screen
                    game.world.height - 5,
                    "paddle",
                    
                );

                //the anchor is always calculated from the top left edge of the object. this line will change the anchor in the middle of the paddle's width and at the bottom of its height so its easier to position against the edge
                paddle.anchor.set(0.5, 1);

                //adding physics to the paddle but not collision yet
                game.physics.enable(paddle, Phaser.Physics.ARCADE);

                //setting the paddle to be immovable when the ball collides with the paddle, since the paddle would previously would get knocked out of the screen
                //may need to find a new place for this since its not applying to lives.
                //moved from update to create and its still not working.
                paddle.body.immovable = true;

                //calling the function to draw the bricks will be here
                initBricks();

                //setting the text style overall for all text so its easier to change it in one place then each individual place
                //saves a lot of space later in code
                textStyle = { font: "18px Arial", fill: "#0095DD" };

                //adding in text for the score
                //this takes four parameters; the x and y coordinates to draw the text at, actual text that will be rendered, font style to render the text with, color
                scoreText = game.add.text(5, 5, "Points: 0", textStyle);

                //adding lives in
                livesText = game.add.text(game.world.width - 5, 5, `Lives: ${lives}`, textStyle,);

                livesText.anchor.set(1, 0);
                lifeLostText = game.add.text(
                    game.world.width * 0.5,
                    game.world.height * 0.5,
                    "Life lost, click to continue",
                    textStyle,
                );
                lifeLostText.anchor.set(0.5);
                lifeLostText.visible = false; //set to false until the life is lost

                //adding in start button here. the parameters are: x and y coords, name of the graphic asset to be displayed, a callback function that is executed when the button is pressed, a reference to 'this' to speccify the execution context. the frames that will be used for the over, out, and down events
                //the over event is the same as hover, out is when the pointer moves out of the button and down is when the button is pressed
                startButton = game.add.button(
                    game.world.width * 0.5,
                    game.world.height * 0.5,
                    "button",
                    startGame,
                    this,
                    1,
                    0,
                    2,
                );
                startButton.anchor.set(0.5);

            } //end of create
            function update() {
                //updates the ball every frame and adds movement. removed when physics engine was introduced.
                //ball.x += 1;
                //ball.y += 1;

                //adding collision between the ball and the paddle that updates every second
                game.physics.arcade.collide(ball, paddle, ballHitPaddle);

                //adds collision between bricks and ball
                game.physics.arcade.collide(ball, bricks, ballHitBrick);

                //stopping the paddle from moving at the start of the game before start is clicked
                if (playing) {
                    paddle.x = game.input.x || game.world.width * 0.5;
                }
            } //end of update
            //writing the function for initializing bricks here
            function initBricks() {
                brickInfo = {
                    width: 50,
                    height: 20,
                    count: {
                        row: 3,
                        col: 7,
                    },
                    offset: {
                        top: 50,
                        left: 60,
                    },
                    padding: 10,
                };
                bricks = game.add.group(); //empty group to contain the bricks

                //nested loop that goes through the rows and columns and creates a new brick on each iteration
                for (let c = 0; c < brickInfo.count.col; c++) {
                    for (let r = 0; r < brickInfo.count.row; r++) {

                        //if coordinates are set to 0, all bricks are drawn in the same place, so brickX and brickY have been updated to draw in different spots. changed from let to const
                        const brickX = (c * (brickInfo.width + brickInfo.padding)) + brickInfo.offset.left; //draws the bricks horizontally
                        const brickY = (r * (brickInfo.height + brickInfo.padding)) + brickInfo.offset.top; //changing the r * to c * will draw bricks on an angle like stairs

                        newBrick = game.add.sprite(brickX, brickY, "brick");
                        game.physics.enable(newBrick, Phaser.Physics.ARCADE); //adding physics to the bricks
                        newBrick.body.immovable = true; //setting it so when the ball hits the brick, it won't knock it outside the screen
                        newBrick.anchor.set(0.5); //setting the anchor to the center of the brick
                        bricks.add(newBrick);
                    }
                }
            } //end of initBricks function

            //creating a function for when the ball hits the bricks. phaser does some heavy lifting here and makes it really easy to clear bricks with collision detection
            //adding in points every time a brick is destroyed
            function ballHitBrick(ball, brick) {
                //brick.kill();
                //making the brick kill animation smoother by adding tweens
                const killTween = game.add.tween(brick.scale); //specifying which property to tween
                killTween.to({ x: 0, y: 0}, 200, Phaser.Easing.Linear.None); //instead of hiding the bricks instantly, we are making the width and height scale to 0 so they disappear nice
                killTween.onComplete.addOnce(() => {
                    brick.kill();
                }, this);
                killTween.start();

                //shorthand syntax for tween above
                //game.add
                    //.tween(brick.scale)
                   // .to({ x: 2, y: 2}, 500, Phaser.Easing.Elastic. Out, true, 100);



                score += 10;
                scoreText.setText(`Points: ${score}`);
                ball.animations.play("wobble"); //ball wobble animation

                //adding in the win text. this loops through the bricks by using bricks.children, checking the aliveness of e ach brick. if there are no more bricks alive, then we show a winning message, and then restart the game
                let count_alive = 0;
                for (let i = 0; i < bricks.children.length; i++) {
                    if (bricks.children[i].alive) {
                        count_alive++;
                    }
                }
                //this section was totally broken before by checking the brick's aliveness in the documentation which felt awkward to write. may have skipped a section on accident or the doc was wrong. looking at source, this is the correct code.
                //actually broke when adding lives i think.

                if (score === brickInfo.count.row * brickInfo.count.col * 10) {
                    alert("You won the game, congratulations!");
                    location.reload();
                }
            } //end of ballHitBrick function

            //adding a function to decrease the number of lives every time the ball leaves the canvas
            //this is saying if there are lives, display the lives and the lives remaining, and then display the lifelost text when a life is lost

            function ballLeaveScreen() {
                lives--;
                if (lives) {
                    livesText.setText(`Lives: ${lives}`);
                    lifeLostText.visible = true;
                    ball.reset(game.world.width * 0.5, game.world.height - 25);
                    paddle.reset(game.world.width * 0.5, game.world.height - 5); //paddle position was not getting reset properly after losing lives. i was multiplying width by width instead of width by height for paddle!
                    
                    //addonce used her when we want a bound function to exceute only one and then its unbound after so its not used again
                    //every outofbounds event, the ballleavescreen will be excuted but when the ball leaves the screen we only want to remove the message from the screen once
                    game.input.onDown.addOnce(() => {
                        lifeLostText.visible = false;
                        ball.body.velocity.set(150, -150);
                    }, this);
                } else {
                    alert("You lost, game over!");
                    location.reload();
                }
            } //end of ballleavescreen function

            //function for ball wobble animation when ball hits paddle

            function ballHitPaddle(ball, paddle) {
                ball.animations.play("wobble");
                //adding variation every time the ball hits the paddle
                ball.body.velocity.x = -1 * 5 * (paddle.x - ball.x);
            }
            //not sure if startGame function should go here but we're putting it here for now
            function startGame() {
                startButton.destroy();
                ball.body.velocity.set(150, -150);
                playing = true;
            } 
                
        </script>
    </body>
</html>